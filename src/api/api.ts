/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * version of an artifact, contains the file and information about deployments
 * @export
 * @interface ArtifactMilestoneTO
 */
export interface ArtifactMilestoneTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    comment?: string;
    /**
     * 
     * @type {number}
     * @memberof ArtifactMilestoneTO
     */
    milestone: number;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    file: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    updatedDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    artifactId: string;
    /**
     * 
     * @type {boolean}
     * @memberof ArtifactMilestoneTO
     */
    latestMilestone: boolean;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneTO
     */
    repositoryId: string;
    /**
     * 
     * @type {Array<DeploymentTO>}
     * @memberof ArtifactMilestoneTO
     */
    deployments: Array<DeploymentTO>;
}
/**
 * Client created Object for updating accessible properties of a version
 * @export
 * @interface ArtifactMilestoneUpdateTO
 */
export interface ArtifactMilestoneUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUpdateTO
     */
    milestoneId?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUpdateTO
     */
    file?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUpdateTO
     */
    comment?: string;
}
/**
 * Client created object for uploading a version from the client
 * @export
 * @interface ArtifactMilestoneUploadTO
 */
export interface ArtifactMilestoneUploadTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUploadTO
     */
    comment?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMilestoneUploadTO
     */
    file?: string;
}
/**
 * Containing metadata for an artifact
 * @export
 * @interface ArtifactTO
 */
export interface ArtifactTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    createdDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    updatedDate: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    fileType: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    lockedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTO
     */
    lockedUntil?: string;
}
/**
 * Specifies properties for supported file types
 * @export
 * @interface ArtifactTypeTO
 */
export interface ArtifactTypeTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    fileExtension: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    svgIcon: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeTO
     */
    url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ArtifactTypeTO
     */
    editable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ArtifactTypeTO
     */
    deployable?: boolean;
}
/**
 * Client created object for updating accessible properties of an artifact
 * @export
 * @interface ArtifactUpdateTO
 */
export interface ArtifactUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    fileType?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactUpdateTO
     */
    file?: string;
}
/**
 * Containing information about a user-repository relation
 * @export
 * @interface AssignmentTO
 */
export interface AssignmentTO {
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof AssignmentTO
     */
    role: AssignmentTORoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AssignmentTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * Containing information about the deployment of an artifact
 * @export
 * @interface DeploymentTO
 */
export interface DeploymentTO {
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    target: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    status: DeploymentTOStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    user: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentTO
     */
    timestamp: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DeploymentTOStatusEnum {
    Pending = 'PENDING',
    Success = 'SUCCESS',
    Error = 'ERROR'
}

/**
 * Client created object for creating a new artifact
 * @export
 * @interface NewArtifactTO
 */
export interface NewArtifactTO {
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    fileType: string;
    /**
     * 
     * @type {string}
     * @memberof NewArtifactTO
     */
    file?: string;
}
/**
 * Client created object containing the deployment target and artifact(-version) id(-s) for creating a new deployment
 * @export
 * @interface NewDeploymentTO
 */
export interface NewDeploymentTO {
    /**
     * 
     * @type {string}
     * @memberof NewDeploymentTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeploymentTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeploymentTO
     */
    milestoneId: string;
    /**
     * 
     * @type {string}
     * @memberof NewDeploymentTO
     */
    target: string;
}
/**
 * Client created object for creating a new repository
 * @export
 * @interface NewRepositoryTO
 */
export interface NewRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof NewRepositoryTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewRepositoryTO
     */
    description: string;
}
/**
 * Containing information about a repository
 * @export
 * @interface RepositoryTO
 */
export interface RepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryTO
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof RepositoryTO
     */
    existingArtifacts: number;
    /**
     * 
     * @type {number}
     * @memberof RepositoryTO
     */
    assignedUsers: number;
}
/**
 * 
 * @export
 * @interface RepositoryUpdateTO
 */
export interface RepositoryUpdateTO {
    /**
     * 
     * @type {string}
     * @memberof RepositoryUpdateTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RepositoryUpdateTO
     */
    description: string;
}
/**
 * 
 * @export
 * @interface ShareWithRepositoryTO
 */
export interface ShareWithRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof ShareWithRepositoryTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof ShareWithRepositoryTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof ShareWithRepositoryTO
     */
    role: ShareWithRepositoryTORoleEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ShareWithRepositoryTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * 
 * @export
 * @interface SharedRepositoryTO
 */
export interface SharedRepositoryTO {
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    artifactId: string;
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    repositoryId: string;
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    role: SharedRepositoryTORoleEnum;
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    artifactName?: string;
    /**
     * 
     * @type {string}
     * @memberof SharedRepositoryTO
     */
    repositoryName?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SharedRepositoryTORoleEnum {
    Owner = 'OWNER',
    Admin = 'ADMIN',
    Member = 'MEMBER',
    Viewer = 'VIEWER'
}

/**
 * Containing all information about an user
 * @export
 * @interface UserInfoTO
 */
export interface UserInfoTO {
    /**
     * 
     * @type {string}
     * @memberof UserInfoTO
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfoTO
     */
    id: string;
}
/**
 * Simplified user object only containing username
 * @export
 * @interface UserTO
 */
export interface UserTO {
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    username: string;
}

/**
 * ArtifactApi - axios parameter creator
 * @export
 */
export const ArtifactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Copy file to other repository
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyToRepository: async (repositoryId: string, artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('copyToRepository', 'repositoryId', repositoryId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('copyToRepository', 'artifactId', artifactId)
            // verify required parameter 'artifactUpdateTO' is not null or undefined
            assertParamExists('copyToRepository', 'artifactUpdateTO', artifactUpdateTO)
            const localVarPath = `/api/artifact/copy/{repositoryId}/{artifactId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an artifact
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact: async (repositoryId: string, newArtifactTO: NewArtifactTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('createArtifact', 'repositoryId', repositoryId)
            // verify required parameter 'newArtifactTO' is not null or undefined
            assertParamExists('createArtifact', 'newArtifactTO', newArtifactTO)
            const localVarPath = `/api/artifact/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newArtifactTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all available file types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFileTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get single artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all artifacts of the given repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsFromRepo: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getArtifactsFromRepo', 'repositoryId', repositoryId)
            const localVarPath = `/api/artifact/repository/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all artifacts of a specific type from a repository
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByRepoIdAndType: async (repositoryId: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getByRepoIdAndType', 'repositoryId', repositoryId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getByRepoIdAndType', 'type', type)
            const localVarPath = `/api/artifact/{repositoryId}/{type}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recent artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all starred artifacts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarred: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/artifact/starred`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lock a Artifact for editing. After calling, the artifact is locked for 10 minutes for the active user. Call the endpoint again, to reset the 10-minutes timer. Has to be called before \"getSingleVersion\" and \"createOrUpdateVersion\"
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('lockArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}/lock`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search artifacts by title.
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts: async (typedTitle: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedTitle' is not null or undefined
            assertParamExists('searchArtifacts', 'typedTitle', typedTitle)
            const localVarPath = `/api/artifact/search/{typedTitle}`
                .replace(`{${"typedTitle"}}`, encodeURIComponent(String(typedTitle)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inverts the star-status (favorite-status) of an artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStarred: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('setStarred', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/starred/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlock a artifact after editing is finished
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockArtifact: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('unlockArtifact', 'artifactId', artifactId)
            const localVarPath = `/api/artifact/{artifactId}/unlock`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an artifact
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifact: async (artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifact', 'artifactId', artifactId)
            // verify required parameter 'artifactUpdateTO' is not null or undefined
            assertParamExists('updateArtifact', 'artifactUpdateTO', artifactUpdateTO)
            const localVarPath = `/api/artifact/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactApi - functional programming interface
 * @export
 */
export const ArtifactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Copy file to other repository
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyToRepository(repositoryId: string, artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyToRepository(repositoryId, artifactId, artifactUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an artifact
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtifact(repositoryId, newArtifactTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all available file types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFileTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTypeTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFileTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get single artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all artifacts of the given repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactsFromRepo(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactsFromRepo(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all artifacts of a specific type from a repository
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByRepoIdAndType(repositoryId: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByRepoIdAndType(repositoryId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get recent artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecent(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all starred artifacts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStarred(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStarred(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lock a Artifact for editing. After calling, the artifact is locked for 10 minutes for the active user. Call the endpoint again, to reset the 10-minutes timer. Has to be called before \"getSingleVersion\" and \"createOrUpdateVersion\"
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search artifacts by title.
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchArtifacts(typedTitle: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchArtifacts(typedTitle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inverts the star-status (favorite-status) of an artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setStarred(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setStarred(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unlock a artifact after editing is finished
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockArtifact(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockArtifact(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an artifact
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifact(artifactId, artifactUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtifactApi - factory interface
 * @export
 */
export const ArtifactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactApiFp(configuration)
    return {
        /**
         * 
         * @summary Copy file to other repository
         * @param {string} repositoryId 
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyToRepository(repositoryId: string, artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.copyToRepository(repositoryId, artifactId, artifactUpdateTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an artifact
         * @param {string} repositoryId 
         * @param {NewArtifactTO} newArtifactTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.createArtifact(repositoryId, newArtifactTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete one Artifact and all of its versions
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all available file types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFileTypes(options?: any): AxiosPromise<Array<ArtifactTypeTO>> {
            return localVarFp.getAllFileTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get single artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifact(artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.getArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all artifacts of the given repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactsFromRepo(repositoryId: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getArtifactsFromRepo(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all artifacts of a specific type from a repository
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByRepoIdAndType(repositoryId: string, type: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getByRepoIdAndType(repositoryId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recent artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecent(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getRecent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all starred artifacts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStarred(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getStarred(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lock a Artifact for editing. After calling, the artifact is locked for 10 minutes for the active user. Call the endpoint again, to reset the 10-minutes timer. Has to be called before \"getSingleVersion\" and \"createOrUpdateVersion\"
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockArtifact(artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.lockArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search artifacts by title.
         * @param {string} typedTitle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts(typedTitle: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.searchArtifacts(typedTitle, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inverts the star-status (favorite-status) of an artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setStarred(artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.setStarred(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlock a artifact after editing is finished
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockArtifact(artifactId: string, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.unlockArtifact(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an artifact
         * @param {string} artifactId 
         * @param {ArtifactUpdateTO} artifactUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any): AxiosPromise<ArtifactTO> {
            return localVarFp.updateArtifact(artifactId, artifactUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactApi - object-oriented interface
 * @export
 * @class ArtifactApi
 * @extends {BaseAPI}
 */
export class ArtifactApi extends BaseAPI {
    /**
     * 
     * @summary Copy file to other repository
     * @param {string} repositoryId 
     * @param {string} artifactId 
     * @param {ArtifactUpdateTO} artifactUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public copyToRepository(repositoryId: string, artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any) {
        return ArtifactApiFp(this.configuration).copyToRepository(repositoryId, artifactId, artifactUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an artifact
     * @param {string} repositoryId 
     * @param {NewArtifactTO} newArtifactTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public createArtifact(repositoryId: string, newArtifactTO: NewArtifactTO, options?: any) {
        return ArtifactApiFp(this.configuration).createArtifact(repositoryId, newArtifactTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete one Artifact and all of its versions
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public deleteArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).deleteArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all available file types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getAllFileTypes(options?: any) {
        return ArtifactApiFp(this.configuration).getAllFileTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get single artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).getArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all artifacts of the given repository
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getArtifactsFromRepo(repositoryId: string, options?: any) {
        return ArtifactApiFp(this.configuration).getArtifactsFromRepo(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all artifacts of a specific type from a repository
     * @param {string} repositoryId 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getByRepoIdAndType(repositoryId: string, type: string, options?: any) {
        return ArtifactApiFp(this.configuration).getByRepoIdAndType(repositoryId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recent artifacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getRecent(options?: any) {
        return ArtifactApiFp(this.configuration).getRecent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all starred artifacts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public getStarred(options?: any) {
        return ArtifactApiFp(this.configuration).getStarred(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lock a Artifact for editing. After calling, the artifact is locked for 10 minutes for the active user. Call the endpoint again, to reset the 10-minutes timer. Has to be called before \"getSingleVersion\" and \"createOrUpdateVersion\"
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public lockArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).lockArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search artifacts by title.
     * @param {string} typedTitle 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public searchArtifacts(typedTitle: string, options?: any) {
        return ArtifactApiFp(this.configuration).searchArtifacts(typedTitle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inverts the star-status (favorite-status) of an artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public setStarred(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).setStarred(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlock a artifact after editing is finished
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public unlockArtifact(artifactId: string, options?: any) {
        return ArtifactApiFp(this.configuration).unlockArtifact(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an artifact
     * @param {string} artifactId 
     * @param {ArtifactUpdateTO} artifactUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactApi
     */
    public updateArtifact(artifactId: string, artifactUpdateTO: ArtifactUpdateTO, options?: any) {
        return ArtifactApiFp(this.configuration).updateArtifact(artifactId, artifactUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeploymentApi - axios parameter creator
 * @export
 */
export const DeploymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deploy artifact milestone
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployMilestone: async (newDeploymentTO: NewDeploymentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newDeploymentTO' is not null or undefined
            assertParamExists('deployMilestone', 'newDeploymentTO', newDeploymentTO)
            const localVarPath = `/api/deploy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newDeploymentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deploy multiple milestones
         * @param {Array<NewDeploymentTO>} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployMultipleMilestones: async (newDeploymentTO: Array<NewDeploymentTO>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newDeploymentTO' is not null or undefined
            assertParamExists('deployMultipleMilestones', 'newDeploymentTO', newDeploymentTO)
            const localVarPath = `/api/deploy/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newDeploymentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentTargets: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/deploy/target`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all deployments of a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentsFromRepository: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getAllDeploymentsFromRepository', 'repositoryId', repositoryId)
            const localVarPath = `/api/deploy/repository/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deploy artifact milestone
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployMilestone(newDeploymentTO: NewDeploymentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployMilestone(newDeploymentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deploy multiple milestones
         * @param {Array<NewDeploymentTO>} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployMultipleMilestones(newDeploymentTO: Array<NewDeploymentTO>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactMilestoneTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployMultipleMilestones(newDeploymentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDeploymentTargets(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDeploymentTargets(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all deployments of a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDeploymentsFromRepository(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDeploymentsFromRepository(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentApiFp(configuration)
    return {
        /**
         * 
         * @summary Deploy artifact milestone
         * @param {NewDeploymentTO} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployMilestone(newDeploymentTO: NewDeploymentTO, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return localVarFp.deployMilestone(newDeploymentTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deploy multiple milestones
         * @param {Array<NewDeploymentTO>} newDeploymentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployMultipleMilestones(newDeploymentTO: Array<NewDeploymentTO>, options?: any): AxiosPromise<Array<ArtifactMilestoneTO>> {
            return localVarFp.deployMultipleMilestones(newDeploymentTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all available deployment targets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentTargets(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getAllDeploymentTargets(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all deployments of a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDeploymentsFromRepository(repositoryId: string, options?: any): AxiosPromise<Array<DeploymentTO>> {
            return localVarFp.getAllDeploymentsFromRepository(repositoryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * 
     * @summary Deploy artifact milestone
     * @param {NewDeploymentTO} newDeploymentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deployMilestone(newDeploymentTO: NewDeploymentTO, options?: any) {
        return DeploymentApiFp(this.configuration).deployMilestone(newDeploymentTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deploy multiple milestones
     * @param {Array<NewDeploymentTO>} newDeploymentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deployMultipleMilestones(newDeploymentTO: Array<NewDeploymentTO>, options?: any) {
        return DeploymentApiFp(this.configuration).deployMultipleMilestones(newDeploymentTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all available deployment targets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getAllDeploymentTargets(options?: any) {
        return DeploymentApiFp(this.configuration).getAllDeploymentTargets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all deployments of a repository
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getAllDeploymentsFromRepository(repositoryId: string, options?: any) {
        return DeploymentApiFp(this.configuration).getAllDeploymentsFromRepository(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MilestoneApi - axios parameter creator
 * @export
 */
export const MilestoneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {string} artifactId 
         * @param {ArtifactMilestoneUploadTO} artifactMilestoneUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMilestone: async (artifactId: string, artifactMilestoneUploadTO: ArtifactMilestoneUploadTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('createMilestone', 'artifactId', artifactId)
            // verify required parameter 'artifactMilestoneUploadTO' is not null or undefined
            assertParamExists('createMilestone', 'artifactMilestoneUploadTO', artifactMilestoneUploadTO)
            const localVarPath = `/api/milestone/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactMilestoneUploadTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a specific milestone
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMilestone: async (artifactId: string, milestoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('downloadMilestone', 'artifactId', artifactId)
            // verify required parameter 'milestoneId' is not null or undefined
            assertParamExists('downloadMilestone', 'milestoneId', milestoneId)
            const localVarPath = `/api/milestone/{artifactId}/{milestoneId}/download`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"milestoneId"}}`, encodeURIComponent(String(milestoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get milestones by providing deploymentIds
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllByDeploymentIds: async (requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('getAllByDeploymentIds', 'requestBody', requestBody)
            const localVarPath = `/api/milestone/deployments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all milestones of the artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMilestones: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getAllMilestones', 'artifactId', artifactId)
            const localVarPath = `/api/milestone/{artifactId}/milestone`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest milestone of the requested milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {number} milestone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByMilestoneNumber: async (artifactId: string, milestone: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getByMilestoneNumber', 'artifactId', artifactId)
            // verify required parameter 'milestone' is not null or undefined
            assertParamExists('getByMilestoneNumber', 'milestone', milestone)
            const localVarPath = `/api/milestone/{artifactId}/milestoneNumber/{milestone}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"milestone"}}`, encodeURIComponent(String(milestone)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the latest milestone of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestMilestone: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getLatestMilestone', 'artifactId', artifactId)
            const localVarPath = `/api/milestone/{artifactId}/milestone/latest`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMilestone: async (artifactId: string, milestoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getMilestone', 'artifactId', artifactId)
            // verify required parameter 'milestoneId' is not null or undefined
            assertParamExists('getMilestone', 'milestoneId', milestoneId)
            const localVarPath = `/api/milestone/{artifactId}/milestone/{milestoneId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"milestoneId"}}`, encodeURIComponent(String(milestoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {ArtifactMilestoneUpdateTO} artifactMilestoneUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMilestone: async (artifactMilestoneUpdateTO: ArtifactMilestoneUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactMilestoneUpdateTO' is not null or undefined
            assertParamExists('updateMilestone', 'artifactMilestoneUpdateTO', artifactMilestoneUpdateTO)
            const localVarPath = `/api/milestone/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(artifactMilestoneUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MilestoneApi - functional programming interface
 * @export
 */
export const MilestoneApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MilestoneApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {string} artifactId 
         * @param {ArtifactMilestoneUploadTO} artifactMilestoneUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMilestone(artifactId: string, artifactMilestoneUploadTO: ArtifactMilestoneUploadTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMilestone(artifactId, artifactMilestoneUploadTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download a specific milestone
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadMilestone(artifactId: string, milestoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadMilestone(artifactId, milestoneId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get milestones by providing deploymentIds
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllByDeploymentIds(requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactMilestoneTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllByDeploymentIds(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all milestones of the artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMilestones(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactMilestoneTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMilestones(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the latest milestone of the requested milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {number} milestone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByMilestoneNumber(artifactId: string, milestone: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByMilestoneNumber(artifactId, milestone, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the latest milestone of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestMilestone(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestMilestone(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMilestone(artifactId: string, milestoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMilestone(artifactId, milestoneId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {ArtifactMilestoneUpdateTO} artifactMilestoneUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMilestone(artifactMilestoneUpdateTO: ArtifactMilestoneUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMilestoneTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMilestone(artifactMilestoneUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MilestoneApi - factory interface
 * @export
 */
export const MilestoneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MilestoneApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {string} artifactId 
         * @param {ArtifactMilestoneUploadTO} artifactMilestoneUploadTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMilestone(artifactId: string, artifactMilestoneUploadTO: ArtifactMilestoneUploadTO, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return localVarFp.createMilestone(artifactId, artifactMilestoneUploadTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a specific milestone
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMilestone(artifactId: string, milestoneId: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadMilestone(artifactId, milestoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get milestones by providing deploymentIds
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllByDeploymentIds(requestBody: Array<string>, options?: any): AxiosPromise<Array<ArtifactMilestoneTO>> {
            return localVarFp.getAllByDeploymentIds(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all milestones of the artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMilestones(artifactId: string, options?: any): AxiosPromise<Array<ArtifactMilestoneTO>> {
            return localVarFp.getAllMilestones(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest milestone of the requested milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {number} milestone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByMilestoneNumber(artifactId: string, milestone: number, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return localVarFp.getByMilestoneNumber(artifactId, milestone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the latest milestone of the requested artifact
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestMilestone(artifactId: string, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return localVarFp.getLatestMilestone(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific milestone, read-permission granted even if Artifact is locked
         * @param {string} artifactId 
         * @param {string} milestoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMilestone(artifactId: string, milestoneId: string, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return localVarFp.getMilestone(artifactId, milestoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
         * @param {ArtifactMilestoneUpdateTO} artifactMilestoneUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMilestone(artifactMilestoneUpdateTO: ArtifactMilestoneUpdateTO, options?: any): AxiosPromise<ArtifactMilestoneTO> {
            return localVarFp.updateMilestone(artifactMilestoneUpdateTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MilestoneApi - object-oriented interface
 * @export
 * @class MilestoneApi
 * @extends {BaseAPI}
 */
export class MilestoneApi extends BaseAPI {
    /**
     * 
     * @summary Create a new milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
     * @param {string} artifactId 
     * @param {ArtifactMilestoneUploadTO} artifactMilestoneUploadTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public createMilestone(artifactId: string, artifactMilestoneUploadTO: ArtifactMilestoneUploadTO, options?: any) {
        return MilestoneApiFp(this.configuration).createMilestone(artifactId, artifactMilestoneUploadTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a specific milestone
     * @param {string} artifactId 
     * @param {string} milestoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public downloadMilestone(artifactId: string, milestoneId: string, options?: any) {
        return MilestoneApiFp(this.configuration).downloadMilestone(artifactId, milestoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get milestones by providing deploymentIds
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getAllByDeploymentIds(requestBody: Array<string>, options?: any) {
        return MilestoneApiFp(this.configuration).getAllByDeploymentIds(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all milestones of the artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getAllMilestones(artifactId: string, options?: any) {
        return MilestoneApiFp(this.configuration).getAllMilestones(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest milestone of the requested milestone, read-permission granted even if Artifact is locked
     * @param {string} artifactId 
     * @param {number} milestone 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getByMilestoneNumber(artifactId: string, milestone: number, options?: any) {
        return MilestoneApiFp(this.configuration).getByMilestoneNumber(artifactId, milestone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the latest milestone of the requested artifact
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getLatestMilestone(artifactId: string, options?: any) {
        return MilestoneApiFp(this.configuration).getLatestMilestone(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific milestone, read-permission granted even if Artifact is locked
     * @param {string} artifactId 
     * @param {string} milestoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public getMilestone(artifactId: string, milestoneId: string, options?: any) {
        return MilestoneApiFp(this.configuration).getMilestone(artifactId, milestoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update milestone of the artifact. (The artifact has to be locked by the user to use this endpoint)
     * @param {ArtifactMilestoneUpdateTO} artifactMilestoneUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MilestoneApi
     */
    public updateMilestone(artifactMilestoneUpdateTO: ArtifactMilestoneUpdateTO, options?: any) {
        return MilestoneApiFp(this.configuration).updateMilestone(artifactMilestoneUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepoAssignmentApi - axios parameter creator
 * @export
 */
export const RepoAssignmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAssignment: async (assignmentTO: AssignmentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignmentTO' is not null or undefined
            assertParamExists('createUserAssignment', 'assignmentTO', assignmentTO)
            const localVarPath = `/api/repoAssignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignmentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user assignment to repository
         * @param {string} repositoryId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAssignment: async (repositoryId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('deleteUserAssignment', 'repositoryId', repositoryId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUserAssignment', 'userId', userId)
            const localVarPath = `/api/repoAssignment/{repositoryId}/{userId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users assigned to a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssignedUsers: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getAllAssignedUsers', 'repositoryId', repositoryId)
            const localVarPath = `/api/repoAssignment/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAssignment: async (assignmentTO: AssignmentTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignmentTO' is not null or undefined
            assertParamExists('updateUserAssignment', 'assignmentTO', assignmentTO)
            const localVarPath = `/api/repoAssignment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignmentTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepoAssignmentApi - functional programming interface
 * @export
 */
export const RepoAssignmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepoAssignmentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAssignment(assignmentTO: AssignmentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAssignment(assignmentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete user assignment to repository
         * @param {string} repositoryId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserAssignment(repositoryId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserAssignment(repositoryId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all users assigned to a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAssignedUsers(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssignmentTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAssignedUsers(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserAssignment(assignmentTO: AssignmentTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssignmentTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserAssignment(assignmentTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepoAssignmentApi - factory interface
 * @export
 */
export const RepoAssignmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepoAssignmentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAssignment(assignmentTO: AssignmentTO, options?: any): AxiosPromise<AssignmentTO> {
            return localVarFp.createUserAssignment(assignmentTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user assignment to repository
         * @param {string} repositoryId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserAssignment(repositoryId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserAssignment(repositoryId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users assigned to a repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssignedUsers(repositoryId: string, options?: any): AxiosPromise<Array<AssignmentTO>> {
            return localVarFp.getAllAssignedUsers(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user assignment to repository
         * @param {AssignmentTO} assignmentTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAssignment(assignmentTO: AssignmentTO, options?: any): AxiosPromise<AssignmentTO> {
            return localVarFp.updateUserAssignment(assignmentTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepoAssignmentApi - object-oriented interface
 * @export
 * @class RepoAssignmentApi
 * @extends {BaseAPI}
 */
export class RepoAssignmentApi extends BaseAPI {
    /**
     * 
     * @summary Create user assignment to repository
     * @param {AssignmentTO} assignmentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoAssignmentApi
     */
    public createUserAssignment(assignmentTO: AssignmentTO, options?: any) {
        return RepoAssignmentApiFp(this.configuration).createUserAssignment(assignmentTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user assignment to repository
     * @param {string} repositoryId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoAssignmentApi
     */
    public deleteUserAssignment(repositoryId: string, userId: string, options?: any) {
        return RepoAssignmentApiFp(this.configuration).deleteUserAssignment(repositoryId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users assigned to a repository
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoAssignmentApi
     */
    public getAllAssignedUsers(repositoryId: string, options?: any) {
        return RepoAssignmentApiFp(this.configuration).getAllAssignedUsers(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user assignment to repository
     * @param {AssignmentTO} assignmentTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepoAssignmentApi
     */
    public updateUserAssignment(assignmentTO: AssignmentTO, options?: any) {
        return RepoAssignmentApiFp(this.configuration).updateUserAssignment(assignmentTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RepositoryApi - axios parameter creator
 * @export
 */
export const RepositoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository: async (newRepositoryTO: NewRepositoryTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newRepositoryTO' is not null or undefined
            assertParamExists('createRepository', 'newRepositoryTO', newRepositoryTO)
            const localVarPath = `/api/repo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newRepositoryTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('deleteRepository', 'repositoryId', repositoryId)
            const localVarPath = `/api/repo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/repo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all repositories that can be managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManageableRepositories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/repo/administration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRepository: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getSingleRepository', 'repositoryId', repositoryId)
            const localVarPath = `/api/repo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for repositories by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRepositories: async (typedName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedName' is not null or undefined
            assertParamExists('searchRepositories', 'typedName', typedName)
            const localVarPath = `/api/repo/search/{typedName}`
                .replace(`{${"typedName"}}`, encodeURIComponent(String(typedName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository: async (repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('updateRepository', 'repositoryId', repositoryId)
            // verify required parameter 'repositoryUpdateTO' is not null or undefined
            assertParamExists('updateRepository', 'repositoryUpdateTO', repositoryUpdateTO)
            const localVarPath = `/api/repo/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(repositoryUpdateTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a repositorie based on its name
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zipDownloadProject: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('zipDownloadProject', 'repositoryId', repositoryId)
            const localVarPath = `/api/repo/{repositoryId}/download`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepositoryApi - functional programming interface
 * @export
 */
export const RepositoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RepositoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRepository(newRepositoryTO: NewRepositoryTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRepository(newRepositoryTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRepository(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRepository(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRepositories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all repositories that can be managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManageableRepositories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManageableRepositories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleRepository(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleRepository(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for repositories by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRepositories(typedName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRepositories(typedName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRepository(repositoryId, repositoryUpdateTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download a repositorie based on its name
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zipDownloadProject(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zipDownloadProject(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RepositoryApi - factory interface
 * @export
 */
export const RepositoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RepositoryApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Repository
         * @param {NewRepositoryTO} newRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRepository(newRepositoryTO: NewRepositoryTO, options?: any): AxiosPromise<RepositoryTO> {
            return localVarFp.createRepository(newRepositoryTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Repository if you own it
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRepository(repositoryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRepository(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Repositories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRepositories(options?: any): AxiosPromise<Array<RepositoryTO>> {
            return localVarFp.getAllRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all repositories that can be managed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManageableRepositories(options?: any): AxiosPromise<Array<RepositoryTO>> {
            return localVarFp.getManageableRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single Repository by providing its ID
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleRepository(repositoryId: string, options?: any): AxiosPromise<RepositoryTO> {
            return localVarFp.getSingleRepository(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for repositories by name
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRepositories(typedName: string, options?: any): AxiosPromise<Array<RepositoryTO>> {
            return localVarFp.searchRepositories(typedName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Repository
         * @param {string} repositoryId 
         * @param {RepositoryUpdateTO} repositoryUpdateTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any): AxiosPromise<RepositoryTO> {
            return localVarFp.updateRepository(repositoryId, repositoryUpdateTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a repositorie based on its name
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zipDownloadProject(repositoryId: string, options?: any): AxiosPromise<any> {
            return localVarFp.zipDownloadProject(repositoryId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RepositoryApi - object-oriented interface
 * @export
 * @class RepositoryApi
 * @extends {BaseAPI}
 */
export class RepositoryApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Repository
     * @param {NewRepositoryTO} newRepositoryTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public createRepository(newRepositoryTO: NewRepositoryTO, options?: any) {
        return RepositoryApiFp(this.configuration).createRepository(newRepositoryTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Repository if you own it
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public deleteRepository(repositoryId: string, options?: any) {
        return RepositoryApiFp(this.configuration).deleteRepository(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getAllRepositories(options?: any) {
        return RepositoryApiFp(this.configuration).getAllRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all repositories that can be managed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getManageableRepositories(options?: any) {
        return RepositoryApiFp(this.configuration).getManageableRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single Repository by providing its ID
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public getSingleRepository(repositoryId: string, options?: any) {
        return RepositoryApiFp(this.configuration).getSingleRepository(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for repositories by name
     * @param {string} typedName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public searchRepositories(typedName: string, options?: any) {
        return RepositoryApiFp(this.configuration).searchRepositories(typedName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Repository
     * @param {string} repositoryId 
     * @param {RepositoryUpdateTO} repositoryUpdateTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public updateRepository(repositoryId: string, repositoryUpdateTO: RepositoryUpdateTO, options?: any) {
        return RepositoryApiFp(this.configuration).updateRepository(repositoryId, repositoryUpdateTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a repositorie based on its name
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepositoryApi
     */
    public zipDownloadProject(repositoryId: string, options?: any) {
        return RepositoryApiFp(this.configuration).zipDownloadProject(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShareApi - axios parameter creator
 * @export
 */
export const ShareApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedArtifacts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/share/artifacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Artifacts shared with Repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifacts: async (repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getSharedArtifacts', 'repositoryId', repositoryId)
            const localVarPath = `/api/share/repository/{repositoryId}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all artifacts that are shared via diverse repositories and filter by artifactType
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifactsByType: async (type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getSharedArtifactsByType', 'type', type)
            const localVarPath = `/api/share/artifacts/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get shared artifacts from repository by type
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifactsFromRepositoryByType: async (repositoryId: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('getSharedArtifactsFromRepositoryByType', 'repositoryId', repositoryId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getSharedArtifactsFromRepositoryByType', 'type', type)
            const localVarPath = `/api/share/repository/{repositoryId}/type/{type}`
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact (Admin permission required)
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedRepositories: async (artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getSharedRepositories', 'artifactId', artifactId)
            const localVarPath = `/api/share/relations/repository/{artifactId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Share an artifact with all members of another repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithRepository: async (shareWithRepositoryTO: ShareWithRepositoryTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareWithRepositoryTO' is not null or undefined
            assertParamExists('shareWithRepository', 'shareWithRepositoryTO', shareWithRepositoryTO)
            const localVarPath = `/api/share/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareWithRepositoryTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareArtifactWithRepository: async (artifactId: string, repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('unshareArtifactWithRepository', 'artifactId', artifactId)
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('unshareArtifactWithRepository', 'repositoryId', repositoryId)
            const localVarPath = `/api/share/repository/unshare/{artifactId}/{repositoryId}`
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the share-role of a relation with a repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareWithRepository: async (shareWithRepositoryTO: ShareWithRepositoryTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareWithRepositoryTO' is not null or undefined
            assertParamExists('updateShareWithRepository', 'shareWithRepositoryTO', shareWithRepositoryTO)
            const localVarPath = `/api/share/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareWithRepositoryTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShareApi - functional programming interface
 * @export
 */
export const ShareApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShareApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSharedArtifacts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSharedArtifacts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Artifacts shared with Repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedArtifacts(repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedArtifacts(repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all artifacts that are shared via diverse repositories and filter by artifactType
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedArtifactsByType(type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedArtifactsByType(type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get shared artifacts from repository by type
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedArtifactsFromRepositoryByType(repositoryId: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedArtifactsFromRepositoryByType(repositoryId, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact (Admin permission required)
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharedRepositories(artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SharedRepositoryTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharedRepositories(artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Share an artifact with all members of another repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareWithRepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareWithRepository(shareWithRepositoryTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unshareArtifactWithRepository(artifactId: string, repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unshareArtifactWithRepository(artifactId, repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the share-role of a relation with a repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareWithRepositoryTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShareWithRepository(shareWithRepositoryTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShareApi - factory interface
 * @export
 */
export const ShareApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShareApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all shared Artifacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSharedArtifacts(options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getAllSharedArtifacts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Artifacts shared with Repository
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifacts(repositoryId: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getSharedArtifacts(repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all artifacts that are shared via diverse repositories and filter by artifactType
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifactsByType(type: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getSharedArtifactsByType(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get shared artifacts from repository by type
         * @param {string} repositoryId 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedArtifactsFromRepositoryByType(repositoryId: string, type: string, options?: any): AxiosPromise<Array<ArtifactTO>> {
            return localVarFp.getSharedArtifactsFromRepositoryByType(repositoryId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all repositories that can access a specific artifact (Admin permission required)
         * @param {string} artifactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharedRepositories(artifactId: string, options?: any): AxiosPromise<Array<SharedRepositoryTO>> {
            return localVarFp.getSharedRepositories(artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Share an artifact with all members of another repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): AxiosPromise<ShareWithRepositoryTO> {
            return localVarFp.shareWithRepository(shareWithRepositoryTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the sharing-relation to a specific repository
         * @param {string} artifactId 
         * @param {string} repositoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unshareArtifactWithRepository(artifactId: string, repositoryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unshareArtifactWithRepository(artifactId, repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the share-role of a relation with a repository
         * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any): AxiosPromise<ShareWithRepositoryTO> {
            return localVarFp.updateShareWithRepository(shareWithRepositoryTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShareApi - object-oriented interface
 * @export
 * @class ShareApi
 * @extends {BaseAPI}
 */
export class ShareApi extends BaseAPI {
    /**
     * 
     * @summary Get all shared Artifacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getAllSharedArtifacts(options?: any) {
        return ShareApiFp(this.configuration).getAllSharedArtifacts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Artifacts shared with Repository
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedArtifacts(repositoryId: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedArtifacts(repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all artifacts that are shared via diverse repositories and filter by artifactType
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedArtifactsByType(type: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedArtifactsByType(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get shared artifacts from repository by type
     * @param {string} repositoryId 
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedArtifactsFromRepositoryByType(repositoryId: string, type: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedArtifactsFromRepositoryByType(repositoryId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all repositories that can access a specific artifact (Admin permission required)
     * @param {string} artifactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public getSharedRepositories(artifactId: string, options?: any) {
        return ShareApiFp(this.configuration).getSharedRepositories(artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Share an artifact with all members of another repository
     * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public shareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any) {
        return ShareApiFp(this.configuration).shareWithRepository(shareWithRepositoryTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the sharing-relation to a specific repository
     * @param {string} artifactId 
     * @param {string} repositoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public unshareArtifactWithRepository(artifactId: string, repositoryId: string, options?: any) {
        return ShareApiFp(this.configuration).unshareArtifactWithRepository(artifactId, repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the share-role of a relation with a repository
     * @param {ShareWithRepositoryTO} shareWithRepositoryTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareApi
     */
    public updateShareWithRepository(shareWithRepositoryTO: ShareWithRepositoryTO, options?: any) {
        return ShareApiFp(this.configuration).updateShareWithRepository(shareWithRepositoryTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of users by providing their Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultipleUsers: async (requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('getMultipleUsers', 'requestBody', requestBody)
            const localVarPath = `/api/user/multiple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the User that is currently sending requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/currentUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the namae of the user that is currently sending requests (name equals email address)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserName: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/registeredEmail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of users that matches the typed letters of a search
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (typedName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'typedName' is not null or undefined
            assertParamExists('searchUsers', 'typedName', typedName)
            const localVarPath = `/api/user/search/{typedName}`
                .replace(`{${"typedName"}}`, encodeURIComponent(String(typedName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of users by providing their Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMultipleUsers(requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfoTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMultipleUsers(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the User that is currently sending requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the namae of the user that is currently sending requests (name equals email address)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserName(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserName(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of users that matches the typed letters of a search
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(typedName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInfoTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers(typedName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(options?: any): AxiosPromise<UserTO> {
            return localVarFp.createUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of users by providing their Ids
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultipleUsers(requestBody: Array<string>, options?: any): AxiosPromise<Array<UserInfoTO>> {
            return localVarFp.getMultipleUsers(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the User that is currently sending requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfo(options?: any): AxiosPromise<UserInfoTO> {
            return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the namae of the user that is currently sending requests (name equals email address)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserName(options?: any): AxiosPromise<string> {
            return localVarFp.getUserName(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of users that matches the typed letters of a search
         * @param {string} typedName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(typedName: string, options?: any): AxiosPromise<Array<UserInfoTO>> {
            return localVarFp.searchUsers(typedName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Create a new User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(options?: any) {
        return UserApiFp(this.configuration).createUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of users by providing their Ids
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMultipleUsers(requestBody: Array<string>, options?: any) {
        return UserApiFp(this.configuration).getMultipleUsers(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the User that is currently sending requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserInfo(options?: any) {
        return UserApiFp(this.configuration).getUserInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the namae of the user that is currently sending requests (name equals email address)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserName(options?: any) {
        return UserApiFp(this.configuration).getUserName(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of users that matches the typed letters of a search
     * @param {string} typedName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public searchUsers(typedName: string, options?: any) {
        return UserApiFp(this.configuration).searchUsers(typedName, options).then((request) => request(this.axios, this.basePath));
    }
}


